# Day 34
## 한 권으로 개발자가 원하던 파이썬 심화 A to Z
### 삼항 연산을 인라인 제어문으로 표시하기
삼항 연산자는 제어문을 인라인으로 작성해서 처리하는데, 한 줄에 제어문을 표기하기 때문에 내부에 문장을 표시할 수 없다.

if else문으로 작성한 경우
```python
x = 10

if x < 10:
    print("x < 10")
else:
    print("x >= 10")
```

삼항 연산자로 작성한 경우
```python
print("x < 10") if x < 10 else print("x >= 10")
```
일반 제어문을 삼항 연산자로 변형할 때는 참인 결과를 먼저 작성하고, 인라인으로 if문을 작성한 후에 else문을 추가한다. 

### switch
특정 조건의 결과가 딕셔너리의 key로 정의되고 해당 값이 함수로 저장되어 특정 조건이 판별되면 딕셔너리를 조회해서 함수를 가져온다. 이렇게 python에는 없는 switch 구문을 유사한 방식으로 만들어 사용할 수 있다.

```python
def func1():
    print(1)

def func2():
    print(2)

switch={'1': func1, '2': func2}

switch['1']() # 색인 연산으로 1을 문자열로 넣고 조회, 함수 func1의 실행 결과를 반환
```
스위치 구문을 처리하는 경우 예외가 발생하지 않도록 get 메소드를 사용하고, 특정 조건이 없는 경우를 대비해서 두 번째 인자에 검색된 결과가 없을 경우 기본으로 처리하는 함수의 이름을 전달한다.
```python
switch.get('2', func1)() # 2 출력

switch.get('10', func1)() # 1 출력, 10이라는 key값이 없어서 예외가 발생하지만 예외 대신 두 번쨰 인자로 전달된 함수를 반환해서 처리한다.
```

### 특정 인덱스 정보로 검색
함수를 이용해 내부의 원소 추출
```python
ll = [1, 2, 3, 4, 5, 6]

def index(iterable, *args):             # 매개변수로 반복형 객체와 인덱스 정보를 받는다.
    result = []                         # 반환 결과를 저장할 변수에 빈 리스트 객체 할당
    for i in args:                      # 가변 인자로 받은 인덱스 정보를 하나씩 꺼낸다.
        if i < len(iterable):           # 반복형 객체의 길이보다 작은지 확인
            result.append(iterable[i])  # 반복형 객체의 원소를 조회해서 빈 리스트에 원소로 추가
        else:
            continue                    # 인덱스 범위를 넘는 수는 처리하지 ㅇ낳고 순환문 처리
    return result                       # 순환문이 종료되면 반환

print(index(ll, 1, 2, 5)) # 함수를 호출해서 인자로 전달한 인덱스의 원소를 리스트에 넣고 조회한다.
                         # 리스트 내의 3개의 원소를 추출한 새로운 리스트 객체가 만들어진다.
                         # [2, 3, 6] 출력, 인덱스 번호 1, 2, 5번에 해당하는 원소들이다.
```
매개변수 iterable은 하나의 리스트 객체를 전달받는다.  
매개변수 args 앞에 별표가 들어간 것은 여러 인자를 받아서 하나의 튜플에서 관리하겠다는 뜻이다.  
인자로 받은 인덱스 정보가 실제 리스트 객체의 길이보다 크거나 같으면 색인 검색에서 리스트 원소의 개수보다 많아져서 예외가 발생하기 때문에 내부 제어문은 인덱스 정보가 원소의 개수보다 작으면 원소를 검색해서 새로운 리스트에 넣어서 전달한다.

operator 모듈은 파이썬 내의 연산자를 함수로 구현한 모듈이다.  
itemgetter은 특정 인덱스에 있는 값을 읽는 클래스이다.
```python
import operator as op

inx = op.itemgetter(1, 2, 5) # 인덱스를 조회하는 클래스로 객체 생성
inx(ll) # 객체에 인자로 리스트를 전달하면 인덱스에 해당하는 원소 반환(튜플)
```

### 함수 정의문
함수는 머리부와 몸체부로 분리해서 정의하며, 머리부에는 함수 이름과 매개변수를, 몸체부는 함수가 처리하는 기능과 반환문을 작성한다.  
파이썬은 반환문이 없어도 None을 반환한다.  
함수를 정의하면 함수 이름이 변수가 되어 함수 객체를 저장하고, 함수 객체가 만들어지면 함수 이름은 \_\_name\_\_ 속성에 저장된다.  
파이썬 함수는 여러 개의 값을 저장해도 하나의 값만 반환하고 여러 개의 값은 하나의 튜플 객체로 처리된다.
```python
def func():
    pass

f = func()
print(f) # None이 자동으로 반환된다.

func.__name__ # 'func' 출력

def func1():
    return 1, 2, 3

f1 = func1()
f1 # (1, 2, 3) 출력
```

### help
파이썬에서 help는 도움말을 보여주는데 이 help도 하나의 클래스이다.  
하나의 인자를 전달하면 그 인자가 관리하는 문서화 속성 \_\_doc\_\_을 조회해서 출력한다.  
함수를 help에 인자로 넣어 실행하면 함수의 머리부와 문서화 문자열이 같이 출력된다.
```python
def add1(x, y):
    """ adding two parameters """
    return x+y

help(add1)
```

### 함수는 1급 객체이다.
1급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 말한다.  
보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원하면 1급 객체라고 한다.  

함수 객체를 일반 정수처럼 다른 변수에 할당할 수도 있다.
```python
def func(x, y):
    return x, y

var = func # 함수 객체는 다른 변수에 할당할 수 있다.
var is func # True 출력, 두 변수는 같은 함수를 참조했기 때문에 레퍼런스가 같다.
```
함수가 정의된 변수 func에 정수 1을 할당하면 기존 함수 객체가 사라지고 정수가 할당되는 것으로 func가 일반적인 변수라는 것을 알 수 있다.
```python
func = 1
func # 1 출력
```
함수를 정의할 때 사용한 함수 이름이 문자열로 저장된다.
```python
var.__name__ # 'func' 출력

func = var
func.__name__ # 'func' 출력
```
함수를 호출할 때 인자로도 전달이 가능하다.
```python
def high_func(func, *args):
    return func(*args)

high_func(func, 1, 3)  # (1, 3) 출력
```
함수를 전달받아 함수를 반환하는 것도 가능하다.
```python
def ret_func(func):
    return func

x = ret_func(func)
x # func 함수가 그대로 반환되었다.
```

### 함수도 이름으로 접근해서 호출
함수 클래스도 디스크립터 클래스이다.  
디스크립터란 \_\_get\_\_, \_\_set\_\_ 또는 \_\_delete\_\_ 중에 하나라도 구현되어 있는 객체를 말한다.  
디스크립터 클래스로 객체를 만들어 변수에 할당하고 실제 이름으로 접근하면 내부적으로 메소드가 자동으로 실행된다.

내부 메소드인 \_\_get\_\_을 참조하여 내무에 정의도니 메소드 객체를 조회할 수 있다.  
디스크립터 클래스에는 스페셜 메소드 \_\_get\_\_이 정의되어 있어 함수의 이름으로 조회하면 함수 객체를 자동으로 가져오기 위해 \_\_get\_\_ 메소드가 자동으로 실행된다.
```python
def add(x, y):
    return x + y

add.__get__ # 함수 객체로 스페셜 메소드 __get__을 조회
```
\_\_get\_\_의 작동 방식
```python
add.__get__(1) # 이 스페셜 메소드에 정수 1을 넣으면 메소드로 변환
               # <bound method add of 1> 출력

b = add.__get__(1) # 메소드로 변환된 것을 변수에 할당

b(2) # 다시 정수 2를 넣고 실행
     # 3 출력, 1 + 2
```
함수에 인자로 1을 넣고 실행하면 정수 객체 1의 메소드로 변환한다.  
이를 변수 b에 할당한 후에 인자 2를 전달해서 실행하면 두 수를 더한 값이 출력된다.

\_\_get\_\_에 None을 전달해서 실행하면 함수가 호출된다.  
보통 함수가 저장된 변수를 참조하면 이 기능이 작동되고 두 번째 인자는 함수를 가져오는데 아무런 역할을 하지 않는 것을 알 수 있다.
```python
add.__get__(None, add) # __get__에서 함수를 호출하려면 첫 번째 인자에 None을 넣는다.
                       # 함수 정의문에서 정의한 함수가 반환

add.__get__(None, 1) # 두 번째 인자에는 다른 값을 넣는다.
                     # 함수 정의문에서 정의한 함수가 반환

a = add.__get__(None, 1) # 함수의 스페셜 메소드에 None을 인자로 넣고 실행한 후에 변수에 할당
a(1, 2) # 호출 연산자와 2개의 인자 전달, 3 출력
```