# Day 22
## Review C
### 문자 변수
```c
char c1 = 'a'; // 문자 변수 c1 선언, a 할당
char c2 = '0'; // 문자 0 저장
char c2 = 0; // 숫자 0 저장
printf("%c, %d", c1, c1); // a, 97: a와 a의 아스키 코드 값 출력

printf("%c %d\n", c1, c1); // 문자 0과 문자 0의 아스키 코드 값 출력

printf("%c %d\n", c2, c2); // 아스키 코드값 0은 NULL이라서 아무것도 출력되지 않고, 뒤에서 정수 0만 출력됨
```

### 제어 문자
```c
char a = '\n' // 한 문자만 들어갈때는 ''써도됨
```

### 상수 사용
```c
const int con1 = 10; // con1은 상수, 10은 리터럴
```
리터럴 : 값 그 자체  
상수 : 변수처럼 리터럴이 저장된 공간

### 리터럴
```c
printf("%d\n", 10); // 정수 리터럴
printf("%f\n", 0.1f); // 실수 리터럴
printf("%c\n", 'a'); // 문자 리터럴
printf("%s\n", "Hello, world!"); // 문자열 리터럴

printf("%d\n", 19); // 10진 정수 리터럴
printf("0%o\n", 017); // 8진 정수 리터럴
printf("0x%X\n", 0x1F); // 16진 정수 리터럴

// 접미사
printf("0%lo\n", 017L); // long 크기의 8진 정수 리터럴
printf("0%lo\n", 017UL); // unsigned long 크기의 8진 정수 리터럴
printf("0x%lX\n", 0x7FFFFFL); // long 크기의 16진 정수 리터럴
printf("0x%lX\n", 0xFFFFFFFFUL); // unsigned long 크기의 16진 정수 리터럴
```

### 입력
```c
#define _CRT_SECURE_NO_WARNINGS //scanf 보안 경고로 인한 컴파일 에러를 방지해줌

scanf("%d", &num1); // 표준 입력을 받아서 변수에 저장

scanf("%d %d", &num1, &num2); // 값을 두개 입력받아 변수 두개에 저장
```

### 덧셈
```c
num1 = 1
num1 = num1 + 2 // 3이 저장, num1 += 2와 같음
```

### 증감 연산자
```c
num1 = 1
num1++; // num1의 값을 1 증가
num1--; // num1의 값을 1 감소
```

### 후위 연산자, 전위 연산자
num3 = num1++; -> 뭔가 한 후에 증감이 동작
1. num3에 num1을 할당
2. num1을 1 증가

num3 = ++num1; -> 뭔가를 하기 전에 증감이 동작
1. num1을 1 증가
2. num3에 num1을 할당

### 나머지 연산
```c
num1 = 10%3 // 10/3의 나머지인 1이 저장
```
c에서 나머지 연산은 a = (a/b) * b + a % b로 정의, a % b를 연산하면 a의 부호를 따른다.

### 실수의 나머지 연산
- <math.h>를 include 해줘야 한다
- fmod(나누어지는수, 나누는수), double형 실수일때 사용
- fmodf(나누어지는수, 나누는수), float형 실수일때 사용
- fmodl(나누어지는수, 나누는수), long double형 실수일때 사용

### 자료형 확장
```c
int num1 = 11;
float num2 = 4.4f;

num3 = num1 + num2; // 정수와 실수를 함께 연산하면 결과값은 실수로 나옴
```
c에서 자료형을 섞어서 쓰면 컴파일러에서 암시적 형 변환 실행, 자료형의 크기가 큰 쪽, 표현 범위가 넓은 쪽으로 자동 변환

마찬가지로 int와 long long이 연산을 했다면 long long쪽으로 변환됨

### 자료형 축소
```c
float num1 = 11.0f;
float num2 = 5.0f;

int num3 = num1 / num2; // 2.2가 나오지만 정수 자료형에는 2만 저장됨

char num4 = 28;
int num5 = 1000000002;

char num6 = num1 + num2; 
// char보다 큰 숫자는 저장할 수 없다.
// 28 + 2만 남고 앞자릿수는 버려짐

printf("%d", num3); // 2 출력
```
1000000002 : 0011 1011 1001 1010 1100 1010 0000 0010  
28 : 0001 1100  
30 : 0011 1011 1001 1010 1100 1010 / 0001 1110

위와 같이 계산됨. char은 8비트이므로 계산 후에 넘치는 앞 자릿수가 버려지고 8비트 부분만 사용되는 것

### if
```c
if (조건식)
{
    조건식이 참일때 실행할 코드;
}
```
if의 조건쪽에 0이 아닌 다른 것은 참으로 인식  
왜냐하면 cpu의 명령어가 그렇게 만들어져 있기 때문, jz와 jnz가 있는데 각각 0일 때, 0이 아닐 때 점프하도록 동작하기 때문

### if else
```c
if (조건식)
{
    조건식이 참일때 실행할 코드;
}
else
{
    조건식이 거짓일때 실행할 코드;
}
```

### else if
```c
if (조건식1)
{
    조건식1이 참일때 실행할 코드;
}
else if (조건식2)
{
    조건식1이 거짓이고 조건식2가 참일때 실행할 코드;
}
```

### if, else if, else
```c
if (조건식1)
{
    조건식1이 참일때 실행할 코드;
}
else if (조건식2)
{
    조건식1이 거짓이고 조건식2가 참일때 실행할 코드;
}
else
{
    조건식1, 조건식2 모두 거짓일 때 실행할 코드;
}
```

### 비교 연산자, 삼항 연산자
|연산자|설명|
|:----:|:--------------------------:|
|==|같음|
|!=|같지 않음|
|>|큼|
|<|작음|
|>=|크거나 같음|
|<=|작거나 같음|
|? : |조건부 연산자. 조건식이 참이면 : 앞의 값을 반환, 거짓이면 : 뒤의 값을 반환|

a = 10, b = 11일때
- a == b : 0
- a != b : 1
- a > b : 0
- a < b : 1
- a >= b : 0
- a <= b : 1

조건식 ? 참일때 사용할 값 : 거짓일때 사용할 값  
ex) num1 == 10 ? 100 : 200;

### 논리 연산자
|연산자|설명|
|:---:|:-----------------:|
|&&|AND(논리곱), 양쪽 모두 참일때 참|
|\|\||OR(논리합), 양쪽 중 한쪽만 참이라도 참|
|!|NOT(논리 부정), 참과 거짓을 뒤집음|

- AND 

|&&|0|1|
|:--:|:-:|:-:|
|0|0|0|
|1|0|1|

- OR

|\|\||0|1|
|:--:|:-:|:-:|
|0|0|1|
|1|1|1|

- NOT

!0 : 1  
!1 : 0

### bool
논리 자료형이라고도 하며 참과 거짓을 나타냄, stdbool.h를 사용하면 0과 1이 아닌 true, false를 사용 가능  
bool은 1바이트

### 비트 연산자
|연산자|설명|
|:---:|:-------------------:|
|&|비트 AND|
|\||비트 OR|
|^|비트 XOR(배타 논리합)|
|~|비트 NOT|
|<<|비트를 왼쪽으로 시프트|
|>>|비트를 오른쪽으로 시프트|
|&=|비트 AND 연산 후 할당|
|\|=|비트 OR 연산 후 할당|
|^=|비트 XOR 연산 후 할당|
|<<=|비트를 왼쪽으로 시프트한 수 할당|
|>>=|비트를 오른쪽으로 시프트한 후 할당|

비트 연산자는 2진수에서 비트 단위로 연산을 진행해줌

시프트 연산에서 <<는 2의 거듭제곱을 곱하는 것과 같고, >>는 2의 거듭제곱을 나누는 것과 같다.  
ex1) 3 << 3 : 3 * 2의 3제곱  
ex2)24 >> 2 : 24 / 2의 2제곱

시프트 연산을 통해 자릿수를 넘어서게 되면 넘어가는 비트들은 사라지게 된다.  
ex) 1100 1000 << 2 == 0010 0000

비트에서 제일 왼쪽에 있는 비트를 최상위 비트, 제일 오른쪽에 있는 비트를 최하위 비트라고 한다.

부호가 있는 자료형에서 첫 번째 비트는 부호비트라고 하여 1이면 음수, 0이면 양수를 나타낸다.

부호가 있는 자료형에서의 시프트 연산은 부호 없는 자료형의 시프트 연산과 다르다.
- 1000 0011 >> 1 : 1100 0001
- 1100 0001 >> 1 : 1110 0000

부호가 없는 자료형은 오른쪽으로 이동시키면 모자라는 공간은 0으로 채워지지만 부호가 있는 자료형은 오른쪽으로 이동시키면 모자라는 공간이 부호비트의 값으로 채워진다.

### switch
```c
switch (값을 판단할 변수)
{
    case 숫자1:
        변수의 값이 숫자1일 때 실행할 코드;
        break;
    case 숫자2:
        변수의 값이 숫자2일 때 실행할 코드;
        break;
    default: // default는 생략 가능
        아무 case에도 해당되지 않을 때 실행할 코드;
        break;
}
```
break가 없으면 그냥 아래로 쭉 내려가면서 실행시켜버린다.

이를 이용하여 코드를 작성할 수도 있다.
```c
switch (num1)
{
    case 1:    // 1 또는
    case 2:    // 2일 때 코드 실행
        printf("1 또는 2입니다.\n");
        break;
    case 3:    // 3 또는
    case 4:    // 4일 때 코드 실행
        printf("3 또는 4입니다.\n");
        break;
    default:
        printf("default\n");
}
```
case 내부에서 변수를 선언하려면 중괄호로 묶어주면 된다.